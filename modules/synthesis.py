# modules/synthesis.py
"""
Module de synthÃ¨se pour l'application juridique
"""
from datetime import datetime
from typing import Any, Dict, List, Optional

import streamlit as st

from utils.formatters import format_date
# Import des utilitaires depuis le package utils
from utils.helpers import clean_key, truncate_text
from utils.text_processing import clean_text, process_text


class SynthesisModule:
    """Classe pour gÃ©rer les synthÃ¨ses juridiques"""
    
    def __init__(self):
        self.name = "SynthÃ¨se"
        self.description = "GÃ©nÃ©ration de synthÃ¨ses juridiques"
        
    def render(self):
        """Affiche l'interface du module de synthÃ¨se"""
        st.header("Module de SynthÃ¨se")
        st.write("CrÃ©ez des synthÃ¨ses complÃ¨tes de vos dossiers juridiques.")
        
        # Options de synthÃ¨se
        col1, col2 = st.columns(2)
        
        with col1:
            synthesis_type = st.selectbox(
                "Type de synthÃ¨se",
                ["SynthÃ¨se gÃ©nÃ©rale", "SynthÃ¨se chronologique", "SynthÃ¨se thÃ©matique", "SynthÃ¨se des piÃ¨ces"]
            )
            
            include_timeline = st.checkbox("Inclure une chronologie", value=True)
            include_pieces = st.checkbox("Inclure la liste des piÃ¨ces", value=True)
            
        with col2:
            max_length = st.slider(
                "Longueur maximale (mots)",
                min_value=500,
                max_value=5000,
                value=2000,
                step=100
            )
            
            format_output = st.selectbox(
                "Format de sortie",
                ["Document Word", "PDF", "Texte brut", "HTML"]
            )
        
        # Zone de saisie pour le contenu Ã  synthÃ©tiser
        st.subheader("Contenu Ã  synthÃ©tiser")
        
        tab1, tab2, tab3 = st.tabs(["Texte direct", "Importer des fichiers", "Depuis le dossier"])
        
        with tab1:
            content_text = st.text_area(
                "Entrez ou collez le contenu Ã  synthÃ©tiser",
                height=300,
                placeholder="Collez ici les Ã©lÃ©ments du dossier Ã  synthÃ©tiser..."
            )
            
        with tab2:
            uploaded_files = st.file_uploader(
                "TÃ©lÃ©chargez des documents",
                type=['pdf', 'docx', 'txt'],
                accept_multiple_files=True
            )
            
            if uploaded_files:
                st.write(f"{len(uploaded_files)} fichier(s) tÃ©lÃ©chargÃ©(s)")
                for file in uploaded_files:
                    st.write(f"- {file.name}")
                    
        with tab3:
            st.info("SÃ©lectionnez les Ã©lÃ©ments du dossier actuel Ã  inclure dans la synthÃ¨se")
            # Ici, on pourrait lister les Ã©lÃ©ments du dossier en session
            
        # Options avancÃ©es
        with st.expander("Options avancÃ©es"):
            st.subheader("Personnalisation de la synthÃ¨se")
            
            col1, col2 = st.columns(2)
            with col1:
                highlight_keywords = st.text_input(
                    "Mots-clÃ©s Ã  mettre en Ã©vidence",
                    placeholder="Ex: responsabilitÃ©, prÃ©judice, dommages"
                )
                
                synthesis_style = st.selectbox(
                    "Style de rÃ©daction",
                    ["Neutre et factuel", "Argumentatif", "Analytique", "SynthÃ©tique"]
                )
                
            with col2:
                include_citations = st.checkbox("Inclure les rÃ©fÃ©rences juridiques", value=True)
                include_analysis = st.checkbox("Inclure une analyse juridique", value=False)
                
            structure_template = st.text_area(
                "Structure personnalisÃ©e (optionnel)",
                placeholder="1. Introduction\n2. Faits\n3. ProcÃ©dure\n4. Moyens\n5. Conclusion",
                height=150
            )
        
        # Bouton de gÃ©nÃ©ration
        col1, col2, col3 = st.columns([1, 2, 1])
        with col2:
            if st.button("ğŸ”„ GÃ©nÃ©rer la synthÃ¨se", type="primary", use_container_width=True):
                if content_text or uploaded_files:
                    with st.spinner("GÃ©nÃ©ration de la synthÃ¨se en cours..."):
                        synthesis = self.generate_synthesis(
                            content=content_text,
                            files=uploaded_files,
                            synthesis_type=synthesis_type,
                            max_length=max_length,
                            options={
                                'include_timeline': include_timeline,
                                'include_pieces': include_pieces,
                                'keywords': highlight_keywords,
                                'style': synthesis_style,
                                'include_citations': include_citations,
                                'include_analysis': include_analysis,
                                'structure': structure_template
                            }
                        )
                        
                        if synthesis:
                            st.success("SynthÃ¨se gÃ©nÃ©rÃ©e avec succÃ¨s!")
                            self.display_synthesis(synthesis, format_output)
                        else:
                            st.error("Erreur lors de la gÃ©nÃ©ration de la synthÃ¨se")
                else:
                    st.warning("Veuillez fournir du contenu Ã  synthÃ©tiser")
        
        # Section des synthÃ¨ses rÃ©centes
        st.divider()
        st.subheader("SynthÃ¨ses rÃ©centes")
        
        recent_syntheses = self.get_recent_syntheses()
        if recent_syntheses:
            for synthesis in recent_syntheses:
                with st.container():
                    col1, col2, col3 = st.columns([3, 1, 1])
                    with col1:
                        st.write(f"**{synthesis['title']}**")
                        st.caption(f"CrÃ©Ã©e le {synthesis['date']}")
                    with col2:
                        st.write(f"Type: {synthesis['type']}")
                    with col3:
                        if st.button("Voir", key=f"view_{synthesis['id']}"):
                            self.display_synthesis(synthesis['content'], synthesis['format'])
        else:
            st.info("Aucune synthÃ¨se rÃ©cente")
    
    def generate_synthesis(self, content: str, files: List[Any], synthesis_type: str, 
                         max_length: int, options: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        GÃ©nÃ¨re une synthÃ¨se basÃ©e sur le contenu fourni.
        
        Args:
            content: Texte Ã  synthÃ©tiser
            files: Fichiers uploadÃ©s
            synthesis_type: Type de synthÃ¨se
            max_length: Longueur maximale en mots
            options: Options de gÃ©nÃ©ration
            
        Returns:
            Dictionnaire contenant la synthÃ¨se gÃ©nÃ©rÃ©e
        """
        # Traitement du contenu
        if content:
            processed_content = process_text(content)
        else:
            processed_content = ""
            
        # Traitement des fichiers (simulation)
        if files:
            # Ici on extrairait le contenu des fichiers
            pass
        
        # GÃ©nÃ©ration de la synthÃ¨se (simulation)
        synthesis = {
            'title': f"SynthÃ¨se {synthesis_type} - {datetime.now().strftime('%d/%m/%Y')}",
            'type': synthesis_type,
            'content': self._create_synthesis_content(processed_content, synthesis_type, options),
            'metadata': {
                'created_at': datetime.now(),
                'max_length': max_length,
                'options': options
            }
        }
        
        # Sauvegarder en session
        if 'syntheses' not in st.session_state:
            st.session_state.syntheses = []
        st.session_state.syntheses.append(synthesis)
        
        return synthesis
    
    def _create_synthesis_content(self, content: str, synthesis_type: str, 
                                options: Dict[str, Any]) -> str:
        """
        CrÃ©e le contenu de la synthÃ¨se selon le type demandÃ©.
        
        Args:
            content: Contenu Ã  synthÃ©tiser
            synthesis_type: Type de synthÃ¨se
            options: Options de gÃ©nÃ©ration
            
        Returns:
            Contenu de la synthÃ¨se
        """
        # Structure de base
        synthesis_parts = []
        
        # En-tÃªte
        synthesis_parts.append(f"# {synthesis_type}")
        synthesis_parts.append(f"*GÃ©nÃ©rÃ©e le {format_date(datetime.now())}*\n")
        
        # Introduction
        synthesis_parts.append("## Introduction")
        intro_text = truncate_text(content, 200) if content else "SynthÃ¨se du dossier juridique."
        synthesis_parts.append(intro_text + "\n")
        
        # Corps selon le type
        if synthesis_type == "SynthÃ¨se gÃ©nÃ©rale":
            synthesis_parts.extend(self._general_synthesis(content, options))
        elif synthesis_type == "SynthÃ¨se chronologique":
            synthesis_parts.extend(self._chronological_synthesis(content, options))
        elif synthesis_type == "SynthÃ¨se thÃ©matique":
            synthesis_parts.extend(self._thematic_synthesis(content, options))
        elif synthesis_type == "SynthÃ¨se des piÃ¨ces":
            synthesis_parts.extend(self._pieces_synthesis(content, options))
        
        # Conclusion
        synthesis_parts.append("\n## Conclusion")
        synthesis_parts.append("Cette synthÃ¨se prÃ©sente les Ã©lÃ©ments essentiels du dossier.")
        
        return "\n".join(synthesis_parts)
    
    def _general_synthesis(self, content: str, options: Dict[str, Any]) -> List[str]:
        """GÃ©nÃ¨re une synthÃ¨se gÃ©nÃ©rale"""
        parts = []
        
        parts.append("## Faits")
        parts.append("Les faits principaux du dossier sont les suivants :")
        parts.append("- [Ã€ complÃ©ter avec les faits extraits]\n")
        
        parts.append("## ProcÃ©dure")
        parts.append("La procÃ©dure s'est dÃ©roulÃ©e comme suit :")
        parts.append("- [Ã€ complÃ©ter avec les Ã©tapes procÃ©durales]\n")
        
        if options.get('include_analysis'):
            parts.append("## Analyse juridique")
            parts.append("L'analyse des Ã©lÃ©ments juridiques rÃ©vÃ¨le :")
            parts.append("- [Ã€ complÃ©ter avec l'analyse]\n")
        
        return parts
    
    def _chronological_synthesis(self, content: str, options: Dict[str, Any]) -> List[str]:
        """GÃ©nÃ¨re une synthÃ¨se chronologique"""
        parts = []
        
        parts.append("## Chronologie des Ã©vÃ©nements")
        parts.append("Les Ã©vÃ©nements se sont dÃ©roulÃ©s dans l'ordre suivant :\n")
        
        # Simulation d'une timeline
        parts.append("### 2024")
        parts.append("- **Janvier** : DÃ©but de la procÃ©dure")
        parts.append("- **Mars** : DÃ©pÃ´t des conclusions")
        parts.append("- **Juin** : Audience de plaidoirie\n")
        
        return parts
    
    def _thematic_synthesis(self, content: str, options: Dict[str, Any]) -> List[str]:
        """GÃ©nÃ¨re une synthÃ¨se thÃ©matique"""
        parts = []
        
        parts.append("## ThÃ¨mes principaux")
        
        themes = ["ResponsabilitÃ©", "PrÃ©judice", "RÃ©paration"]
        for theme in themes:
            parts.append(f"\n### {theme}")
            parts.append(f"Concernant {theme.lower()}, il ressort que :")
            parts.append("- [Ã‰lÃ©ments relatifs au thÃ¨me]")
        
        return parts
    
    def _pieces_synthesis(self, content: str, options: Dict[str, Any]) -> List[str]:
        """GÃ©nÃ¨re une synthÃ¨se des piÃ¨ces"""
        parts = []
        
        parts.append("## Inventaire des piÃ¨ces")
        parts.append("Le dossier comprend les piÃ¨ces suivantes :\n")
        
        parts.append("### PiÃ¨ces du demandeur")
        parts.append("1. Assignation")
        parts.append("2. Conclusions")
        parts.append("3. PiÃ¨ces justificatives\n")
        
        parts.append("### PiÃ¨ces du dÃ©fendeur")
        parts.append("1. Conclusions en rÃ©ponse")
        parts.append("2. PiÃ¨ces contradictoires\n")
        
        return parts
    
    def display_synthesis(self, synthesis: Dict[str, Any], format_output: str):
        """
        Affiche la synthÃ¨se gÃ©nÃ©rÃ©e.
        
        Args:
            synthesis: SynthÃ¨se Ã  afficher
            format_output: Format de sortie souhaitÃ©
        """
        # Affichage du contenu
        if isinstance(synthesis, dict) and 'content' in synthesis:
            content = synthesis['content']
        else:
            content = str(synthesis)
            
        st.markdown(content)
        
        # Options d'export
        st.divider()
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.download_button(
                label=f"ğŸ“¥ TÃ©lÃ©charger ({format_output})",
                data=content,
                file_name=f"synthese_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt",
                mime="text/plain"
            )
            
        with col2:
            if st.button("ğŸ“§ Envoyer par email"):
                st.info("Fonction d'envoi par email Ã  implÃ©menter")
                
        with col3:
            if st.button("ğŸ’¾ Sauvegarder dans le dossier"):
                st.success("SynthÃ¨se sauvegardÃ©e dans le dossier")
    
    def get_recent_syntheses(self) -> List[Dict[str, Any]]:
        """
        RÃ©cupÃ¨re les synthÃ¨ses rÃ©centes depuis la session.
        
        Returns:
            Liste des synthÃ¨ses rÃ©centes
        """
        if 'syntheses' not in st.session_state:
            return []
            
        # Retourner les 5 derniÃ¨res synthÃ¨ses
        syntheses = st.session_state.syntheses[-5:]
        
        # Formater pour l'affichage
        formatted = []
        for i, synthesis in enumerate(syntheses):
            formatted.append({
                'id': i,
                'title': synthesis.get('title', 'Sans titre'),
                'type': synthesis.get('type', 'Inconnue'),
                'date': synthesis.get('metadata', {}).get('created_at', datetime.now()).strftime('%d/%m/%Y %H:%M'),
                'content': synthesis,
                'format': 'text'
            })
            
        return formatted[::-1]  # Inverser pour avoir les plus rÃ©centes en premier

# Point d'entrÃ©e du module
def get_module():
    """Retourne une instance du module"""
    return SynthesisModule()